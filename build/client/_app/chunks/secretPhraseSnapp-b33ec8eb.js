import{k as E,b as i,K as I,a as N,h as M,J as q,c as A,P as y,i as T,I as H,d as k,Y as c,D as x,L as C,W as P}from"./index-b3f6643b.js";var O=Object.defineProperty,L=Object.getOwnPropertyDescriptor,D=(t,e,s,r)=>{for(var n=r>1?void 0:r?L(e,s):e,o=t.length-1,l;o>=0;o--)(l=t[o])&&(n=(r?l(e,s,n):l(n))||n);return r&&n&&O(e,s,n),n};function u(t,e){if(typeof e=="number"){if(!Number.isInteger(e))throw new Error(`${t} expected integer argument. Got ${e}`);return new i(e)}else return e.value}function z(t){const e=[];for(let s=7;s>=0;s--)e.push((t>>s&1)===1);return e}function F(t){return t.map(r=>Number(Boolean(r))).reduce((r,n)=>r<<1|n)}const a=class extends I{value;static get zero(){return new a(i.zero)}constructor(t){super();this.value=t}toString(){return this.value.toString()}toNumber(){return Number(this.value.toString())}toChar(){return String.fromCharCode(Number(this.value.toString()))}toBits(){const t=this.toNumber();return z(t)}static check(t){t.value.rangeCheckHelper(8).assertEquals(t.value)}static MAXINT(){return new a(i.fromJSON(((1n<<8n)-1n).toString()))}static fromNumber(t){return new a(u("UInt8.fromNumber",t))}static fromBits(t){return this.fromNumber(F(t))}static NUM_BITS=8;divMod(t){let e=this.value,s=u("UInt8.div",t);if(this.value.isConstant()&&s.isConstant()){let v=BigInt(e.toString()),w=BigInt(s.toString()),b=v/w,_=v-b*w;return[new a(new i(b.toString())),new a(new i(_.toString()))]}s=s.seal();let r=N.witness(i,()=>new i((BigInt(e.toString())/BigInt(s.toString())).toString()));r.rangeCheckHelper(a.NUM_BITS).assertEquals(r);let n=e.sub(r.mul(s)).seal();n.rangeCheckHelper(a.NUM_BITS).assertEquals(n);let o=new a(n),l=new a(r);return o.assertLt(new a(s)),[l,o]}div(t){return this.divMod(t)[0]}mod(t){return this.divMod(t)[1]}mul(t){let e=this.value.mul(u("UInt8.mul",t));return e.rangeCheckHelper(a.NUM_BITS).assertEquals(e),new a(e)}add(t){let e=this.value.add(u("UInt8.add",t));return e.rangeCheckHelper(a.NUM_BITS).assertEquals(e),new a(e)}sub(t){let e=this.value.sub(u("UInt8.sub",t));return e.rangeCheckHelper(a.NUM_BITS).assertEquals(e),new a(e)}lte(t){let e=this.value.sub(u("UInt8.lte",t)).seal(),s=e.rangeCheckHelper(a.NUM_BITS).equals(e),r=e.rangeCheckHelper(a.NUM_BITS).equals(e.neg());return s.or(r).assertEquals(!0),r}assertLte(t){let e=u("UInt8.lt",t).sub(this.value).seal();e.rangeCheckHelper(a.NUM_BITS).assertEquals(e)}lt(t){return this.lte(t).and(this.value.equals(t.value).not())}assertLt(t){this.lt(t).assertEquals(!0)}gt(t){return t.lt(this)}assertGt(t){t.assertLt(this)}};let m=a;D([E],m.prototype,"value",2);const Y=2**5;class p extends I{value;constructor(e){super();if(e.length>Y)throw new Error("string cannot exceed character limit");const s=e.split("").map(r=>m.fromNumber(r.charCodeAt(0)));this.value=s}repr(){return this.value.map(e=>e.toNumber())}toString(){return this.value.map(e=>String.fromCharCode(Number(e.toString()))).join("")}toBits(){const e=[];return this.value.forEach(s=>{s.toBits().forEach(r=>e.push(r))}),e}toField(){const e=this.value.map(r=>r.value);let s=i.zero;for(let r=0,n=i.one;r<Math.min(e.length,31);r++,n=n.mul(256))s=s.add(e[r].mul(n));return s}static fromField(e){const s=[];e.toConstant().value[1].forEach(o=>{s.push(m.fromNumber(o))});const n=new p("");return n.value=s,n}static fromBits(e){typeof e[0]!="boolean"&&(e=e.map(n=>n.toBoolean()));const s=[];for(let n=0;n<e.length;n+=8){const o=e.slice(n,n+8),l=m.fromBits(o);s.push(l)}const r=new p("");return r.value=s,r}hash(){return M.hash(this.value.map(e=>i(e.toString())))}}class g extends q{constructor(e){super(e);this.secretPhrase=A()}deploy(e,s){super.deploy(),this.balance.addInPlace(e),console.log(s),this.secretPhrase.set(s.hash())}async guessPhrase(e){const s=await this.secretPhrase.get();return N.if(s.equals(e.hash()),new y(!0),new y(!1))}}T(i)(g.prototype,"secretPhrase");Reflect.metadata("design:paramtypes",[String])(g.prototype,"guessPhrase");H(g.prototype);async function R(){const e=k.random().toPublicKey(),s=new g(e),r={title:"Secret Phrase Snapp",guessPhrase(o){return $(e,o)},getSnappState(){return B(e)},address:e};return console.log(s),await c.transaction(U,async()=>{console.log("Deploying Secret Phrase Snapp...");const o=await x.createSigned(S),l=new p("mina is cool");console.assert(f.assertEquals(C.fromNumber(1e6))),o.balance.subInPlace(f),s.deploy(f,l),console.log(s)}).send().wait(),await c.getAccount(e),console.log(e),console.log(h),console.log("Deployed..."),r}async function B(t){return console.log(t),console.log(h),{secretPhraseHash:(await c.getAccount(t)).snapp.appState[0].toString()}}async function $(t,e){const s=new g(t),r=new p(e),n=c.transaction(S,async()=>{console.log(`Guessing Phrase ${e}...`),await s.guessPhrase(r)});try{await n.send().wait()}catch(l){console.log(`Transaction Failed! Error: ${l}`)}const o=(await B(t)).secretPhraseHash;return r.hash().toString()==o?"winner":"loser"}async function X(){await P}let h,d,U,S,f;P.then(()=>{h=c.LocalBlockchain(),c.setActiveInstance(h),d=h.testAccounts.map(t=>t.privateKey),U=d[0],S=d[1],f=C.fromNumber(1e6)});export{g as SecretPhraseSnapp,R as deploy,B as getSnappState,$ as guessPhrase,X as load};
